<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>note Typing Game</title>

<style>
body {
  font-family: system-ui, sans-serif;
  padding: 20px;
}
#jp {
  font-size: 22px;
  margin-bottom: 8px;
}
#roma {
  font-size: 16px;
  word-break: break-all;
}
.correct {
  color: #2ecc71;
}
.current {
  text-decoration: underline;
}
#input {
  margin-top: 10px;
  font-size: 18px;
  width: 100%;
}
#status {
  margin-top: 8px;
  font-weight: bold;
}
</style>
</head>
<body>

<h1>note „Çø„Ç§„Éî„É≥„Ç∞</h1>

<div id="jp">Ë™≠„ÅøËæº„Åø‰∏≠‚Ä¶</div>
<div id="roma"></div>

<input id="input" autocomplete="off" />
<div id="status"></div>

<!-- wanakanaÔºàÂÆâÂÆöÁâàÔºâ -->
<script src="https://unpkg.com/wanakana@5.3.1/wanakana.min.js"></script>

<!-- kuromojiÔºà„É≠„Éº„Ç´„É´Ôºâ -->
<script src="./kuromoji.js"></script>

<script>
/* ===============================
   Ë®≠ÂÆö
================================ */
const RSS_URL =
  "https://api.rss2json.com/v1/api.json?rss_url=https://note.com/info/rss";

/* ===============================
   „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
================================ */
// HTML„Çø„Ç∞Èô§Âéª
function stripHtml(html) {
  const div = document.createElement("div");
  div.innerHTML = html;
  return div.textContent || "";
}

// ÊñáÂàÜÂâ≤ÔºàÁ∞°ÊòìÔºâ
function splitSentences(text) {
  return text
    .replace(/\n+/g, "")
    .split(/„ÄÇ/)
    .map(s => s.trim())
    .filter(Boolean)
    .map(s => s + "„ÄÇ");
}

/* ===============================
   note RSS Ë™≠„ÅøËæº„Åø
================================ */
async function loadNoteText() {
  const res = await fetch(RSS_URL);
  const json = await res.json();

  const body = json.items
    .map(item => stripHtml(item.content))
    .join("");

  return splitSentences(body);
}

/* ===============================
   „Ç≤„Éº„É†ÈñãÂßã
================================ */
(async function () {
  const sentences = await loadNoteText();
  let index = 0;

  kuromoji.builder({ dicPath: "./dict" }).build((err, tokenizer) => {
    if (err) {
      document.getElementById("jp").textContent = "ËæûÊõ∏Ë™≠„ÅøËæº„ÅøÂ§±Êïó";
      return;
    }
    nextSentence();

    function nextSentence() {
      if (index >= sentences.length) {
        document.getElementById("jp").textContent = "üéâ ÂÖ®Êñá„ÇØ„É™„Ç¢ÔºÅ";
        return;
      }

      const jpText = sentences[index++];
      startGame(jpText, tokenizer);
    }

    function startGame(jpText, tokenizer) {
      const jp = document.getElementById("jp");
      const romaDiv = document.getElementById("roma");
      const input = document.getElementById("input");
      const status = document.getElementById("status");

      jp.textContent = jpText;
      input.value = "";
      input.disabled = false;
      input.focus();

      const tokens = tokenizer.tokenize(jpText);
      const reading = tokens.map(t => t.reading || t.surface_form).join("");
      const hira = wanakana.toHiragana(reading, { passRomaji: true });
      const roma = wanakana.toRomaji(hira, { IMEMode: false });

      renderRoma("");

      input.oninput = () => {
        const val = input.value;

        if (!roma.startsWith(val)) {
          status.textContent = "‚ùå „Éü„Çπ";
          return;
        }

        status.textContent = "OK";
        renderRoma(val);

        if (val === roma) {
          status.textContent = "‚úî Ê¨°„Å∏";
          input.disabled = true;
          setTimeout(nextSentence, 600);
        }
      };

      function renderRoma(typed) {
        const correct = roma.slice(0, typed.length);
        const rest = roma.slice(typed.length);

        romaDiv.innerHTML =
          `<span class="correct">${correct}</span>` +
          (rest
            ? `<span class="current">${rest[0]}</span>${rest.slice(1)}`
            : "");
      }
    }
  });
})();
</script>

</body>
</html>
